/*
 * Copyright 2000-2013 JetBrains s.r.o.
 * Copyright 2014-2018 AS3Boyan
 * Copyright 2014-2014 Elias Ku
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// Generated by Haxe 3.4.7
package haxe.lang;

import haxe.root.*;

@SuppressWarnings(value={"rawtypes", "unchecked"})
public class StringExt
{
	public StringExt()
	{
	}
	
	
	public static String charAt(String me, int index)
	{
		
			if ( index >= me.length() || index < 0 )
				return "";
			else
				return Character.toString(me.charAt(index));
	
	}
	
	
	public static Object charCodeAt(String me, int index)
	{
		
			if ( index >= me.length() || index < 0 )
				return null;
			else
				return (int) me.charAt(index);
	
	}
	
	
	public static int indexOf(String me, String str, Object startIndex)
	{
		
			int sIndex = (startIndex != null ) ? (Runtime.toInt(startIndex)) : 0;
			if (sIndex >= me.length() || sIndex < 0)
				return -1;
			return me.indexOf(str, sIndex);
	
	}
	
	
	public static int lastIndexOf(String me, String str, Object startIndex)
	{
		
			int sIndex = (startIndex != null ) ? (Runtime.toInt(startIndex)) : (me.length() - 1);
			if (sIndex > me.length() || sIndex < 0)
				sIndex = me.length() - 1;
			else if (sIndex < 0)
				return -1;
			return me.lastIndexOf(str, sIndex);
	
	}
	
	
	public static haxe.root.Array<String> split(String me, String delimiter)
	{
		
			Array<String> ret = new Array<String>();

			int slen = delimiter.length();
			if (slen == 0)
			{
				int len = me.length();
				for (int i = 0; i < len; i++)
				{
					ret.push(me.substring(i, i + 1));
				}
			} else {
				int start = 0;
				int pos = me.indexOf(delimiter, start);

				while (pos >= 0)
				{
					ret.push(me.substring(start, pos));

					start = pos + slen;
					pos = me.indexOf(delimiter, start);
				}

				ret.push(me.substring(start));
			}
			return ret;
	
	}
	
	
	public static String substr(String me, int pos, Object len)
	{
		
			int meLen = me.length();
			int targetLen = meLen;
			if (len != null)
			{
				targetLen = Runtime.toInt(len);
				if (targetLen == 0)
					return "";
				if( pos != 0 && targetLen < 0 ){
					return "";
				}
			}

			if( pos < 0 ){
				pos = meLen + pos;
				if( pos < 0 ) pos = 0;
			} else if( targetLen < 0 ){
				targetLen = meLen + targetLen - pos;
			}

			if( pos + targetLen > meLen ){
				targetLen = meLen - pos;
			}

			if ( pos < 0 || targetLen <= 0 ) return "";

			return me.substring(pos, pos + targetLen);
	
	}
	
	
	public static String substring(String me, int startIndex, Object endIndex)
	{
		
		int endIdx;
		int len = me.length();
		if ( endIndex == null) {
			endIdx = len;
		} else if ( (endIdx = Runtime.toInt(endIndex)) < 0 ) {
			endIdx = 0;
		} else if ( endIdx > len ) {
			endIdx = len;
		}

		if ( startIndex < 0 ) {
			startIndex = 0;
		} else if ( startIndex > len ) {
			startIndex = len;
		}

		if ( startIndex > endIdx ) {
			int tmp = startIndex;
			startIndex = endIdx;
			endIdx = tmp;
		}

		return me.substring(startIndex, endIdx);

	
	}
	
	
	public static String toString(String me)
	{
		//line 174 "C:\\HaxeToolkit\\haxe\\std\\java\\internal\\StringExt.hx"
		return me;
	}
	
	
	public static String toLowerCase(String me)
	{
		
			return me.toLowerCase();
	
	}
	
	
	public static String toUpperCase(String me)
	{
		
			return me.toUpperCase();
	
	}
	
	
	public static String toNativeString(String me)
	{
		//line 195 "C:\\HaxeToolkit\\haxe\\std\\java\\internal\\StringExt.hx"
		return me;
	}
	
	
	public static String fromCharCode(int code)
	{
		
		return Character.toString( (char) code );
	
	}
	
	
}


