/*
 * Copyright 2018-2018 m0rkeulv
 * Copyright 2019-2020 Eric Bishton
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



plugins {
    id 'de.undercouch.download' version '3.3.0'
    id 'org.jetbrains.intellij' version '1.13.3'
    id "org.jetbrains.grammarkit" version "2022.3.1"
    id "com.asarkar.gradle.build-time-tracker" version "2.0.4"
    id 'com.adarshr.test-logger' version '3.2.0'
}

import org.jetbrains.intellij.DependenciesUtils
import org.jetbrains.grammarkit.tasks.*

allprojects {
    repositories { mavenCentral() }

    ext {
        // modules
        haxeCommonDir = "${rootDir}/common"
        haxePluginDir = "${rootDir}"

        // generated sources
        generatedSrcDir = "${haxePluginDir}/gen/"
        generatedTestSrcDir = "${haxePluginDir}/genTest/"

        // dependencies
        dependenciesDir = "${rootDir}/dependencies"
        downloadsDir = "${dependenciesDir}/downloads"
        toolDir = "${dependenciesDir}/tools"
        ideaBaseDir = "${rootDir}/idea-IU"
        ideaTargetDir = "${ideaBaseDir}/ideaIU-${ideaVersion}"

        grammerDir = "${haxePluginDir}/grammar"
        //Note: path is system directory separator sensitive, file.absolutePath solves this for us
        grammarHaxe = file("${grammerDir}/haxe.bnf").absolutePath
        grammarHxml = file("${grammerDir}/hxml.bnf").absolutePath
        grammarMetadata = file("${grammerDir}/metadata.bnf").absolutePath


        haxeFlex = file("${grammerDir}/haxe.flex").absolutePath
        hxmlFlex = file("${grammerDir}/hxml.flex").absolutePath
        metadataFlex = file("${grammerDir}/metadata.flex").absolutePath


        flexDownloadFile = "idea-flex-${ideaVersion}.skeleton"
        flexTargetFile = "idea-flex.skeleton"

        grammarKitDownloadFile = "GrammarKit-${grammarKitVersion}.zip"
        grammarKitTargetFile = "grammar-kit.jar"

        psiDownloadFile = "light-psi-all-${grammarKitVersion}.jar"
        psiTargetFile = "light-psi-all.jar"
    }

    apply plugin: 'idea'
    apply plugin: 'org.jetbrains.intellij'
    apply from: "${haxePluginDir}/testSettings.gradle"

    intellij {
        type = 'IU'
        version = "IU-${ideaVersion}"
        pluginName = "intellij-haxe-${ideaVersion}"
        ideaDependencyCachePath = "${ideaBaseDir}"
        // Specify the sandbox so that Gradle doesn't try to make it relative to each sub-project.
        sandboxDir = "${project.rootDir}/build/idea-sandbox"
        // Don't let gradle fill in since/until, we fill them via patchCustomTags using the properties file.
        updateSinceUntilBuild = false

        plugins.add('java')
        // search marketplace for flex plugin to find the version matching your target
        plugins.add('com.intellij.flex:223.8617.9');
    }
}

//Download build tools
apply from: 'dependencies/tools.gradle'

build.dependsOn('setupTools')
test.dependsOn('setupTools')


if (!file("$generatedSrcDir").exists()) file("$generatedSrcDir").mkdirs()


sourceSets.main.java.srcDirs = ['src/common', 'src/icons', 'gen']
sourceSets.main.resources.srcDir 'resources'

sourceSets.test.java.srcDirs = [ 'testSrc', "genTest"]
sourceSets.test.resources.srcDir 'testData'

idea.module { generatedSourceDirs += file('gen') }


dependencies {
    implementation 'ch.qos.reload4j:reload4j:1.2.25'

    implementation files('gen') {
        builtBy 'generateSources'
    }

    implementation project(':common')
    implementation project(':jps-plugin')
    implementation project(':hxcpp-debugger-protocol')

    String flexShared = "${ideaTargetDir}/config/plugins/flex/lib/flex-shared.jar"
    String flexSupport = "${ideaTargetDir}/config/plugins/flex/lib/FlexSupport.jar"

    compileOnly files(flexShared)
    compileOnly files(flexSupport)
    compileOnly files("${ideaTargetDir}/lib/openapi.jar")
    compileOnly files("${ideaTargetDir}/lib/util.jar")


    testCompileOnly project(':jps-plugin')
    testCompileOnly project(':common')
    testCompileOnly project(':hxcpp-debugger-protocol')


    testCompileOnly files(flexShared)
    testCompileOnly files(flexSupport)
    testCompileOnly files("${ideaTargetDir}/lib/openapi.jar")
    testCompileOnly files("${ideaTargetDir}/lib/util.jar")

}

afterEvaluate {
    dependencies {
        implementation DependenciesUtils.intellijPlugin(project, 'java') {
            include("${ideaTargetDir}/plugins/java/lib/jps-builders.jar")
        }
    }
}

runIde {

    /* Propagate VM options from gradle command line through to the plugin. */
    String[] prefixesToInclude = [ "idea.", "jb." ]
    Properties props = System.getProperties()
    for (String pname : props.propertyNames()) {
        for (String prefix : prefixesToInclude) {
            if (pname.startsWith(prefix) && pname != 'idea.home.path') {
                String pval = props.get(pname)
                if (pval.contains(" ") && !pval.startsWith("'")) {
                    // Strings containing spaces require quoting.
                    // Double-quotes seem to be removed with JvmExec, but single-quotes work.
                    // Some internal Java settings (e.g. os.name) have quotes stripped anyway.
                    pval = "'" + pval + "'"
                }
                systemProperties.put(pname, pval)
                break
            }
        }
    }
}

compileJava {
    sourceCompatibility = 17
    dependsOn 'generateSources'
}

processResources {
    from('src/common') {
        includeEmptyDirs = false
        include '**/*.properties'
//        include 'META-INF/*.xml'
    }
}

processResources {
    from('src') {
        include 'META-INF/pluginIcon.svg'
        include 'META-INF/pluginIcon_dark.svg'
    }
}

patchPluginXml {
    def props = findSdkValuesAndProperties()
    sinceBuild = props.getProperty("plugin.installable.since")
    untilBuild = props.getProperty("plugin.installable.until")

    pluginXmlFiles = [
            file('src/META-INF/plugin.xml'),
            file('src/META-INF/debugger-support.xml'),
            file('src/META-INF/flex-debugger-support.xml')
    ]
}

patchPluginXml.finalizedBy('patchCustomTags')
task patchCustomTags() {
    doFirst {
        file(patchPluginXml.destinationDir.toString() + '/plugin.xml')
                .renameTo(patchPluginXml.destinationDir.toString() + '/plugin.xml.partial')
    }
    doLast {
        copy {
            def props =findSdkValuesAndProperties()
            from(patchPluginXml.destinationDir.toString() + '/plugin.xml.partial')
            filter(ReplaceTokens, tokens: props)
            into patchPluginXml.destinationDir.toString()
            rename('plugin.xml.partial', 'plugin.xml')
        }

    }
    doLast {
        delete file(patchPluginXml.destinationDir.toString() + '/plugin.xml.partial')
    }
}

jar {
    baseName = "intellij-haxe"
    include('**/*').includeEmptyDirs(false)
    // include submodules
    from(project(':jps-plugin').sourceSets.main.output).include('**/*').includeEmptyDirs(false)
    from(project(':common').sourceSets.main.output).include('**/*').includeEmptyDirs(false)
    from(project(':hxcpp-debugger-protocol').sourceSets.main.output).include('**/*').includeEmptyDirs(false)

    from(zipTree("${ideaTargetDir}/lib/forms_rt.jar")).include('com/intellij/uiDesigner/core/*.class')
}
jar.finalizedBy('copyJar')

task copyJar() {
    doLast {
        def props = findSdkValuesAndProperties();
        def jarName = "intellij-haxe-" + props.getProperty("idea.version") + ".jar"
        copy {
            from("${haxePluginDir}/build/libs/").include(jar.archiveName)
            into("${rootDir}/")
            rename({jarName})
        }
    }
}

test {
    useJUnit()
    allJvmArgs = [
      "-Didea.home.path=${ideaTargetDir}",
      "-Xbootclasspath/a:${ideaTargetDir}/lib/boot.jar",
      "-Dfile.encoding=UTF-8",
      "-ea",
      "-Didea.launcher.bin.path=${ideaTargetDir}/bin"
    ]
}

clean.dependsOn('cleanGenerated')
task cleanGenerated(type: Delete, group: 'generate') {
    outputs.upToDateWhen { !file("$generatedSrcDir").exists() }
    outputs.upToDateWhen { !file("$generatedTestSrcDir").exists() }
    delete "$generatedSrcDir"
    delete "$generatedTestSrcDir"
}

task generateHaxeParser(group: 'generate',  type: GenerateParserTask) {
    group = "parsers"
    targetRoot.set("${generatedSrcDir}")
    sourceFile.set(file("${grammarHaxe}"))
    pathToParser.set("com/intellij/plugins/haxe/lang/parser/HaxeParser.java")
    pathToPsiRoot.set("com/intellij/plugins/haxe/lang")
}

task generateHaxeLexer(group: 'generate', dependsOn:'generateHaxeParser', type: GenerateLexerTask) {
    sourceFile.set(file("${haxeFlex}"))
    targetDir.set("${generatedSrcDir}/com/intellij/plugins/haxe/lang/lexer")
    targetClass.set("com.intellij.plugins.haxe.lang.lexer._HaxeLexer")

    inputs.file "${haxeFlex}"
    outputs.upToDateWhen { file("${generatedSrcDir}/com/intellij/plugins/haxe/lang/lexer/_HaxeLexer.java").exists() }
}

task generateHxmlLexer(group: 'generate', dependsOn:'generateHxmlParser', type: GenerateLexerTask) {
    sourceFile.set(file("${hxmlFlex}"))
    targetDir.set("${generatedSrcDir}/com/intellij/plugins/haxe/hxml/lexer")
    targetClass.set("com.intellij.plugins.haxe.hxml.lexer.HXMLLexer")

    inputs.file "${hxmlFlex}"
    outputs.upToDateWhen { file("${generatedSrcDir}/com/intellij/plugins/haxe/hxml/lexer/HXMLLexer.java").exists() }

}

task generateMetadataLexer(group: 'generate', dependsOn:'generateMetadataParser', type: GenerateLexerTask) {
    sourceFile.set(file("${metadataFlex}"))
    targetDir.set("${generatedSrcDir}/com/intellij/plugins/haxe/metadata/lexer")
    targetClass.set("com.intellij.plugins.haxe.metadata.lexer.MetadataLexer")

    inputs.file "${metadataFlex}"
    outputs.upToDateWhen { file("${generatedSrcDir}/com/intellij/plugins/haxe/metadata/lexer/MetadataLexer.java").exists() }
}



task generateHxmlParser(group: 'generate',  type: GenerateParserTask) {
    group = "parsers"
    targetRoot.set("${generatedSrcDir}")
    sourceFile.set(file("${grammarHxml}"))
    pathToParser.set("com/intellij/plugins/haxe/hxml/HXMLParser")
    pathToPsiRoot.set("com/intellij/plugins/haxe/hxml")

    inputs.file "${grammarHxml}"
    outputs.upToDateWhen { file("${generatedSrcDir}/com/intellij/plugins/haxe/hxml").exists() }
}

task generateMetadataParser(group: 'generate',  type: GenerateParserTask) {
    group = "parsers"
    targetRoot.set("${generatedSrcDir}")
    sourceFile.set(file("${grammarMetadata}"))
    pathToParser.set("com/intellij/plugins/haxe/metadata/parser/HaxeMetadataParser")
    pathToPsiRoot.set("com/intellij/plugins/haxe/metadata")

    inputs.file "${grammarMetadata}"
    outputs.upToDateWhen { file("${generatedSrcDir}/com/intellij/plugins/haxe/metadata").exists() }
}

import groovy.xml.MarkupBuilder
import org.apache.tools.ant.filters.ReplaceTokens
import org.gradle.api.tasks.testing.logging.TestExceptionFormat
import org.gradle.api.tasks.testing.logging.TestLogEvent


task cleanGenDirIfSourcesChanged(group: 'other') {
    inputs.dir "${grammerDir}"
    outputs.dir "${grammerDir}"
    doLast {
        delete "$generatedSrcDir"
    }

}
task generateSources(group: 'generate') {
    dependsOn 'cleanGenDirIfSourcesChanged'
    dependsOn 'generateHaxeLexer'
    dependsOn 'generateHxmlLexer'
    dependsOn 'generateMetadataLexer'
}

Properties findSdkValuesAndProperties() {

    def properties = new Properties()
    file("${rootDir}/properties/idea.properties").withInputStream { properties.load(it) }

    properties.setProperty('idea.sdk.version', "$ideaVersion")
    properties.setProperty('plugin.dev.version', project.hasProperty('devBuild') ? "${project.devBuild}" : '')

    return properties
}

tasks.withType(Test) {
    // force all tests to run every time
    dependsOn "cleanTest"

    // output summary and any failed or skipped tests

    // from https://stackoverflow.com/questions/3963708/gradle-how-to-display-test-results-in-the-console-in-real-time
    testLogging {
        events TestLogEvent.FAILED,
                TestLogEvent.SKIPPED

        exceptionFormat TestExceptionFormat.FULL
        showExceptions true
        showCauses true
        showStackTraces true

        info.events = debug.events
        info.exceptionFormat = debug.exceptionFormat

        afterSuite { desc, result ->
            if (!desc.parent) { // will match the outermost suite
                def output = "Results: ${result.resultType} (${result.testCount} tests, ${result.successfulTestCount} successes, ${result.failedTestCount} failures, ${result.skippedTestCount} skipped)"
                def startItem = '|  ', endItem = '  |'
                def repeatLength = startItem.length() + output.length() + endItem.length()
                println('\n' + ('-' * repeatLength) + '\n' + startItem + output + endItem + '\n' + ('-' * repeatLength))
            }
        }
    }
}


task checkForMissingRunConfigurations() {
    def runConfigurationsDir = new File(".idea/runConfigurations")
    if (!runConfigurationsDir.exists()) {
        generateRunConfigurations()
    }
}

task regenerateRunConfigurations() {
    doLast {
        generateRunConfigurations()
    }
}

private void generateRunConfigurations() {



    createGradleRunConfiguration('Run IDE (default)', 'runIde', '', '-Didea.is.internal=true')
    createGradleRunConfiguration('Run IDE (default) - Suppress ProcessCanceledExceptions', 'runIde', '', '-Didea.is.internal=true -Didea.ProcessCanceledException=disabled')
    createGradleRunConfiguration('Run Tests (default)', 'test', '', '')
    createGradleRunConfiguration('Run Single Test (default)', 'test', '', '--tests "{replace this with FQDN of test suite or single test}"')

    createGradleRunConfiguration('Generate Parsers', 'cleanGenerated generateHaxeParser generateHxmlParser', '', '')

}

// create IDEA run configurations from Gradle JavaExec tasks
private void createGradleRunConfiguration(String configName, String taskList,String scriptParams, String vmOptions) {


    def runConfigurationsDir = new File(".idea/runConfigurations")
    runConfigurationsDir.mkdirs()

    def writer = new FileWriter(new File(runConfigurationsDir, "${configName.replaceAll("\\s", "_")}.xml"))
    def xml = new MarkupBuilder(writer)

    xml.component(name: "ProjectRunConfigurationManager") {
        configuration(default: 'false', name: configName, type: "GradleRunConfiguration", factoryName: "Gradle") {
            ExternalSystemSettings() {
                option(name: 'executionName')
                option(name: 'externalProjectPath', value: '$PROJECT_DIR$')
                option(name: 'externalSystemIdString', value: "GRADLE")
                option(name: 'scriptParameters', value: scriptParams)
                option(name: 'taskNames') {
                    list() {
                        for (String task : taskList.split('\\s')) {
                            option(value: task)
                        }
                    }
                }
                option(name: 'vmOptions', value: vmOptions)
            }
        }
    }
}
