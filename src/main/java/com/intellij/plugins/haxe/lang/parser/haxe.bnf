{
    parserClass="com.intellij.plugins.haxe.lang.parser.HaxeParser"
    parserUtilClass="com.intellij.plugins.haxe.lang.parser.utils.HaxeGeneratedParserUtilBase"

    implements="com.intellij.plugins.haxe.lang.psi.HaxePsiCompositeElement"
    extends="com.intellij.plugins.haxe.lang.psi.impl.HaxePsiCompositeElementImpl"

    psiClassPrefix="Haxe"
    psiImplClassSuffix="Impl"
    psiPackage="com.intellij.plugins.haxe.lang.psi"
    psiImplPackage="com.intellij.plugins.haxe.lang.psi.impl"

    elementTypeHolderClass="com.intellij.plugins.haxe.lang.lexer.HaxeTokenTypes"
    elementTypeClass="com.intellij.plugins.haxe.lang.lexer.HaxeElementType"
    tokenTypeFactory="com.intellij.plugins.haxe.lang.lexer.HaxeElementType.createToken"

    generateFirstCheck=100

    tokens = [

    // enclosures
    ENCLOSURE_CURLY_BRACKET_LEFT='{'
    ENCLOSURE_CURLY_BRACKET_RIGHT='}'
    ENCLOSURE_BRACKET_LEFT='['
    ENCLOSURE_BRACKET_RIGHT=']'
    ENCLOSURE_PARENTHESIS_LEFT='('
    ENCLOSURE_PARENTHESIS_RIGHT =')'

    // keywords (toplevel)
    KEYWORD_PACKAGE='package'
    KEYWORD_IMPORT ='import'
    KEYWORD_USING ='using'

    KEYWORD_CLASS='class'
    KEYWORD_ENUM='enum'
    KEYWORD_ABSTRACT='abstract'
    KEYWORD_INTERFACE='interface'

    KEYWORD_IMPLEMENTS='implements'
    KEYWORD_EXTENDS='extends'

    KEYWORD_UNTYPED='untyped'
    KEYWORD_TYPEDEF='typedef'
    KEYWORD_EXTERN='extern'

    // keywords (code-flow)
    KEYWORD_IF ='if'
    KEYWORD_ELSE ='else'

    KEYWORD_SWITCH ='switch'
    KEYWORD_CASE='case'
    KEYWORD_DEFAULT='default'

    KEYWORD_FOR ='for'
    KEYWORD_DO ='do'
    KEYWORD_WHILE ='while'
    KEYWORD_BREAK='break'
    KEYWORD_CONTINUE ='continue'
    KEYWORD_RETURN='return'
    KEYWORD_THROW ='throw'

    KEYWORD_TRY='try'
    KEYWORD_CATCH='catch'

    // keywords (declarations)
    KEYWORD_VAR='var'
    KEYWORD_FUNCTION='function'
    KEYWORD_NEW='new'

    // keywords (access)
    KEYWORD_PUBLIC='public'
    KEYWORD_PRIVATE='private'
    KEYWORD_FINAL='final'
    KEYWORD_STATIC='static'
    KEYWORD_OVERRIDE='override'

    KEYWORD_THIS ='this'
    KEYWORD_SUPER ='super'

    //keywords (misc)
    KEYWORD_MACRO='macro'


    KEYWORD_DYNAMIC='dynamic'
    KEYWORD_IS='is'
    KEYWORD_CAST='cast'
    KEYWORD_INLINE='inline'
    KEYWORD_NEVER='never'

    // keywords (Abstracts)
//    KEYWORD_FROM='from'
//    KEYWORD_TO='to'

    // keyword values
    KEYWORD_NULL ='null'
    KEYWORD_TRUE ='true'
    KEYWORD_FALSE ='false'

    // conditional compilation
    CONDITIONAL_COMPILATION_IF='#if'
    CONDITIONAL_COMPILATION_ELSE='#else'
    CONDITIONAL_COMPILATION_ELSEIF='#elseif'
    CONDITIONAL_COMPILATION_END='#end'
    CONDITIONAL_COMPILATION_ERROR='#error'
    CONDITIONAL_COMPILATION_LINE='#line'

    // operators
    OPERATOR_SEMICOLON=';'
    OPERATOR_COLON=':'
    OPERATOR_COMMA=','
    OPERATOR_DOT='.'
    OPERATOR_EQ='=='
    OPERATOR_ASSIGN='='
    OPERATOR_NOT_EQ='!='
    OPERATOR_NOT='!'
    OPERATOR_COMPLEMENT='~'
    OPERATOR_PLUS_PLUS='++'
    OPERATOR_PLUS_ASSIGN='+='
    OPERATOR_PLUS='+'
    OPERATOR_MINUS_MINUS='--'
    OPERATOR_MINUS_ASSIGN='-='
    OPERATOR_MINUS='-'

    OPERATOR_TERNARY='?'

    OPERATOR_COND_OR='||'
    OPERATOR_BIT_OR='|'
    OPERATOR_BIT_OR_ASSIGN='|='

    OPERATOR_COND_AND='&&'

    OPERATOR_BIT_AND_ASSIGN='&='
    OPERATOR_BIT_AND='&'

    OPERATOR_SHIFT_LEFT_ASSIGN='<<='
    OPERATOR_SHIFT_LEFT='<<'
    OPERATOR_LESS_OR_EQUAL='<='
    OPERATOR_LESS='<'

    OPERATOR_BIT_XOR_ASSIGN='^='
    OPERATOR_BIT_XOR='^'

    OPERATOR_MUL_ASSIGN='*='
    OPERATOR_MUL='*'

    OPERATOR_QUOTIENT_ASSIGN='/='
    OPERATOR_QUOTIENT='/'

    OPERATOR_REMAINDER_ASSIGN='%='
    OPERATOR_REMAINDER='%'

    OPERATOR_UNSIGNED_SHIFT_RIGHT_ASSIGN='>>>='
    OPERATOR_UNSIGNED_SHIFT_RIGHT='>>>'
    OPERATOR_SHIFT_RIGHT_ASSIGN='>>='
    OPERATOR_SHIFT_RIGHT='>>'

    OPERATOR_GREATER_OR_EQUAL='>='
    OPERATOR_GREATER='>'

    OPERATOR_TRIPLE_DOT='...'
    OPERATOR_IN='in'
    OPERATOR_ARROW='->'

    OPERATOR_FAT_ARROW='=>'


    //numeric values
    LITERAL_INTEGER='regexp:[0-9]+'
    LITERAL_HEXADECIMAL='regexp:(0x|0X)[0-9A-Fa-f]+'
    LITERAL_OCTAL='regexp:0[0-7]+'
    LITERAL_FLOAT='regexp:((([0-9]*\.[0-9]+)|([0-9]+\.[0-9]*))([eE][+-]?[0-9])?)|([0-9]+([eE][+-]?[0-9]))'
    // misc
    LITERAL_SPACE='regexp:\s+'

    ID='regexp:\p{Alpha}\w*'
    MACRO_ID='regexp:[\w\d]+(\.[\w\d]+)*'

//    COMPILE_META='regex:@:\p{Alpha}\w*'
//    RUNTIME_META='regex:@\p{Alpha}\w*'


    ]


    /* Name the various productions, to make cleaner error statements for the user. */
    name(".*Expression")="expression"
    name(".*Literal")="literal expression"
    name(".*KeyWord")="keyword"
    name(".*Operator")="operator"
    name(".*Operation")="operation"
    name(".*Statement")="statement"

    extends(".*Expression")=expression // Must be by itself to use the Pratt algorithm for recursion.
    extends(".*Literal")=expression
    extends(".*Metadata")="com.intellij.plugins.haxe.metadata.psi.impl.HaxeMetaImpl"
    implements(".*Metadata")="com.intellij.plugins.haxe.metadata.psi.HaxeMeta"
    /* extends(".*Statement")="statement"
     */
    implements(".*Statement")="com.intellij.plugins.haxe.lang.psi.HaxeStatementPsiMixin"
    mixin(".*Statement")="com.intellij.plugins.haxe.lang.psi.impl.HaxeStatementPsiMixinImpl"
    pin(".*Statement")=1


    generate=[names="long" ]
}



HaxePsiFile ::= packageStatement? topLevelList

//TODO, clean up,  added for the sake of tokenType Gen
private cc ::= CC_BAD_CHARACTER | CC_LITERAL_INTEGER | CC_LITERAL_HEXADECIMAL | CC_LITERAL_OCTAL | CC_LITERAL_FLOAT | CC_KEYWORD_TRUE | CC_KEYWORD_FALSE | CC_OPERATOR_EQ | CC_OPERATOR_NOT_EQ | CC_OPERATOR_NOT | CC_OPERATOR_GREATER_OR_EQUAL | CC_OPERATOR_GREATER | CC_OPERATOR_LESS_OR_EQUAL | CC_OPERATOR_LESS | CC_OPERATOR_COND_AND | CC_OPERATOR_COND_OR
private cc_ex ::=  CONDITIONAL_ID |CONDITIONAL_COMPILATION_EXPRESSION_START | CONDITIONAL_COMPILATION_EXPRESSION_END | CC_ENCLOSURE_PARENTHESIS_LEFT | CC_ENCLOSURE_PARENTHESIS_RIGHT |CC_OPERATOR_DOT | CC_OPERATOR_COMMA
private cc_STR ::=  CC_OPEN_QUOTE |CC_OPEN_APOSTROPHE | CC_REGULAR_STRING_PART| CC_CLOSING_QUOTE| CC_CLOSING_APOSTROPHE|CC_STRING_ESCAPE


//private ppConditionalStatement ::= CONDITIONAL_STATEMENT_ID
ppConditionalStatement ::= (cc | cc_ex)* { recoverWhile=ppConditionalStatement_recover}
private ppConditionalStatement_recover ::= !(ppToken)

private ppToken ::= '#if' | "#elseif" | "#else" | "#end" | "#error" | "#line"


/*
 * Operators.  Priority is ascending; that is: the stuff lower down in the file
 * is matched before things closer to the top.  Thus, unsignedShiftRight must come
 * after shiftRight so that it has priority.
 */
fake operator ::= ":" | ";" | "," |"." | "==" | "=" | "!=" | "!" | "~" | "++" | "+=" | "+" | "--" | "-="
              | "-" | "?" | "||" | "|" | "|=" | "&&" | "&=" | "&" | "<<=" | "<<" | "<=" | "<" | "^="
              | "^" | "*=" | "*" | "/=" | "/" | "%=" | "%"
              | <<unsignedShiftRightAssign>> | <<shiftRightAssign>> | <<unsignedShiftRight>> | <<shiftRight>>
              | <<gtEq>> | ">" | "..." | "in" | '->' | "=>" | "new" | "is"

shiftLeftOperator ::= '<<'                                          { extends=operator }
shiftRightOperator ::= <<shiftRight>>                               { extends=operator }
unsignedShiftRightOperator ::= <<unsignedShiftRight>>               { extends=operator }

shiftLeftAssignOperator ::= '<<='                                   { extends=operator }
shiftRightAssignOperator ::= <<shiftRightAssign>>                   { extends=operator }
unsignedShiftRightAssignOperator ::= <<unsignedShiftRightAssign>>   { extends=operator }

shiftOperator ::= unsignedShiftRightOperator | shiftRightOperator | shiftLeftOperator
shiftAssignOperator ::= unsignedShiftRightAssignOperator | shiftRightAssignOperator | shiftLeftAssignOperator

// TODO: Rename *.operation rules to *.operator.
assignOperation ::= '=' | '%=' | '*=' | '/=' | '+=' | '-=' | '&=' | '|=' | '^=' | shiftAssignOperator  { extends=operator }
private gt ::= '>' !'>' // Cheaper than the predicates for all of the possible shift operators.
compareOperation ::= '==' | '!=' | '<=' | '<' | <<gtEq>> | gt     { extends=operator }
bitOperation ::= '|' | '&' | '^'      { extends=operator }

// These are private simply so that the test goldens don't all have to be updated.
private additiveOperator ::= '+' | '-'        { extends=operator }
private assignableOperator ::= '++' | '--'    { extends=operator }
private colonOperator ::= ':'                 { extends=operator }
isOperator ::= 'is'                   { extends=operator }
private iteratorOperator ::= '...'            { extends=operator }
private logicAndOperator ::= '&&'             { extends=operator }
private logicOrOperator ::= '||'              { extends=operator }
private moduloOperator ::= '%'                { extends=operator }
private multiplicativeOperator ::= '*' | '/'  { extends=operator }
private prefixOperator ::= '-' | '!' | '~'    { extends=operator }
private questionOperator ::= '?'              { extends=operator }
private suffixOperator ::= '!'                { extends=operator }

// KFROM and KTO are only keywords for abstracts and can be used as identifiers elsewhere in the code
identifier ::= ID | KFROM | KTO
{mixin="com.intellij.plugins.haxe.lang.psi.impl.HaxeIdentifierPsiMixinImpl" implements="com.intellij.plugins.haxe.lang.psi.HaxeIdentifierPsiMixin" name="identifier"}

thisExpression ::= 'this'
{mixin="com.intellij.plugins.haxe.lang.psi.impl.HaxeReferenceImpl" implements="com.intellij.plugins.haxe.lang.psi.HaxeReference"}

superExpression ::= 'super'
{mixin="com.intellij.plugins.haxe.lang.psi.impl.HaxeReferenceImpl" implements="com.intellij.plugins.haxe.lang.psi.HaxeReference"}

packageStatement ::= 'package' simpleQualifiedReferenceExpression? ';'
{
    pin=1
    name='package statement'
    implements="com.intellij.plugins.haxe.lang.psi.HaxePackageStatementPsiMixin"
    mixin="com.intellij.plugins.haxe.lang.psi.impl.HaxePackageStatementPsiMixinImpl"
}

private topLevelList ::= topLevel*
private topLevel ::= importStatement | usingStatement |  (metadataDeclaration* topLevelDeclaration) | moduleDeclaration
{
    recoverWhile="top_level_recover"
    name="import, using, or top level declaration"
}
private top_level_recover ::= !(ppToken | metadataDeclaration | 'abstract' | 'class'  | 'enum' | 'extern' | 'import' | 'using' | 'interface' | 'private' | 'typedef' | 'final' | 'function' |  'var' )


metadataDeclaration ::= (compileTimeMetadata | runTimeMetadata)
metadataType ::= META_TYPE
metadataContent ::= (metadataCompiletimeContent | metadataRuntimeContent)
//private metadataCompiletimeContent ::='(' compileTimeMetaArgList ')'
//private metadataRuntimeContent ::='('runTimeMetaArgList ')'
private metadataCompiletimeContent ::='(' compileTimeMetaArgList ')'
private metadataRuntimeContent ::='(' runTimeMetaArgList ')'

compileTimeMetadata  ::= COMPILE_META_PREFIX metadataType metadataCompiletimeContent? {pin=1}
runTimeMetadata ::= RUNTIME_META_PREFIX metadataType metadataRuntimeContent? {pin=1}

private compileTimeMetaArg ::= expression
private compileTimeMetaArgList ::= compileTimeMetaArg (',' compileTimeMetaArg)*

private runTimeMetaArg ::= arrayLiteral | objectLiteral | constantExpression
private runTimeMetaArgList ::= runTimeMetaArg (',' runTimeMetaArg)*

// for recovery use
private metaKeyWord ::= metadataDeclaration

private importAlias ::= ('in' | 'as') identifier
{
    elementType="identifier"
}
importWildcard ::= '.*'
importStatement ::= 'import' simpleQualifiedReferenceExpression [importWildcard | importAlias]';'
{
  implements="com.intellij.plugins.haxe.lang.psi.HaxeImportStatementPsiMixin"
  mixin="com.intellij.plugins.haxe.lang.psi.impl.HaxeImportStatementPsiMixinImpl"
  methods=[
    alias="identifier";
    wildcard="importWildcard"
  ]
}

usingStatement ::= 'using' simpleQualifiedReferenceExpression ';'
{
  implements="com.intellij.plugins.haxe.lang.psi.HaxeUsingStatementPsiMixin"
  mixin="com.intellij.plugins.haxe.lang.psi.impl.HaxeUsingStatementPsiMixinImpl"
}

private topLevelDeclaration ::= classDeclaration
                              | interfaceDeclaration
                              | externClassDeclaration
                              | externInterfaceDeclaration
                              | abstractClassDeclaration
                              | abstractDeclaration
                              | enumDeclaration
                              | typedefDeclaration

{
    name="Top Level Declaration (class, interface, abstract, enum, or typedef)"
}

privateKeyWord ::= 'private'
externKeyWord ::= 'extern'
finalKeyWord ::= 'final'

private externPrivate ::= externKeyWord privateKeyWord
private privateExtern ::= privateKeyWord externKeyWord
private externOrPrivate ::= externPrivate | privateExtern | privateKeyWord | externKeyWord

private externAndMaybePrivate1 ::= privateKeyWord? externKeyWord
private externAndMaybePrivate2 ::= externKeyWord privateKeyWord?
private externAndMaybePrivate ::= externAndMaybePrivate2 | externAndMaybePrivate1

classModifier ::= privateKeyWord | finalKeyWord
classModifierList ::= classModifier+
private externClassModifier ::= classModifier | externKeyWord
// This is intentionally vague (allowing multiple 'extern's), so that the following class parses.
// The semantic annotator takes care of warning about duplicate extern keywords.
externClassModifierList ::= classModifier* externKeyWord externClassModifier* {extends=classModifierList}

typedefDeclaration ::= externOrPrivate? 'typedef' componentName genericParam? '=' typeWrapper ';'?
{
    pin=5
    mixin="com.intellij.plugins.haxe.lang.psi.impl.AbstractHaxeTypeDefImpl"
    implements="com.intellij.plugins.haxe.lang.psi.HaxeClass"
}

externClassDeclaration ::= externClassModifierList 'class' componentName genericParam? inheritList? externClassDeclarationBody
{
    pin=3
    mixin="com.intellij.plugins.haxe.lang.psi.impl.AbstractHaxePsiClass"
    implements="com.intellij.plugins.haxe.lang.psi.HaxeClass"
}
externClassDeclarationBody ::= '{' externClassDeclarationBodyPart* '}'
private externClassDeclarationBodyPart ::= fieldDeclaration | methodDeclaration | constructorDeclaration {recoverWhile="extern_class_body_part_recover"}
private extern_class_body_part_recover ::= !(pptoken | metaKeyWord | 'dynamic' | 'extern' | 'function' | 'inline' | 'override' | 'private' | 'public' | 'static' | 'var' | 'final' | '}')

externInterfaceDeclaration ::= externAndMaybePrivate? 'interface' componentName genericParam? inheritList? interfaceBody
{
    pin=3
    mixin="com.intellij.plugins.haxe.lang.psi.impl.AbstractHaxePsiClass"
    implements="com.intellij.plugins.haxe.lang.psi.HaxeClass"
}

moduleDeclaration ::= moduleBody
{
    pin=1
}

classDeclaration ::= classModifierList? 'class' componentName genericParam? inheritList? classBody
{
    pin=3
    mixin="com.intellij.plugins.haxe.lang.psi.impl.AbstractHaxePsiClass"
    implements="com.intellij.plugins.haxe.lang.psi.HaxeClass"
}

abstractClassDeclaration ::= privateKeyWord? abstractClassType componentName genericParam?  inheritList? abstractClassBody
{
    pin=3
    mixin="com.intellij.plugins.haxe.lang.psi.impl.AbstractHaxePsiClass"
    implements="com.intellij.plugins.haxe.lang.psi.HaxeClass"
}

abstractClassType ::=  'abstract' 'class'
abstractClassBody ::=  '{' abstractClassBodyPart* '}'  {pin=1}
private abstractClassBodyPart ::= abstractMethod | fieldDeclaration | methodDeclaration | constructorDeclaration {recoverWhile="class_body_part_recover"}
abstractMethod ::= abstractMethodModifier* 'abstract' abstractMethodModifier*  'function' methodDeclarator typeTag ';'  {pin=5 }


abstractDeclaration ::= privateKeyWord? abstractType componentName genericParam? underlyingType (abstractToType | abstractFromType)* abstractBody
{
    pin=3
    mixin="com.intellij.plugins.haxe.lang.psi.impl.AbstractHaxePsiClass"
    implements="com.intellij.plugins.haxe.lang.psi.HaxeClass"
}
abstractType ::= 'enum'? 'abstract'
abstractToType ::= 'to' ('(' typeWrapper ')' | typeWrapper){pin=1}
abstractFromType ::= 'from' ('(' typeWrapper ')' | typeWrapper){pin=1}

//'from' | 'to'
underlyingType ::= '(' typeWrapper ')' | typeWrapper
abstractBody ::= '{' abstractBodyPart* '}' {extends="classBody"}
private abstractBodyPart ::= fieldDeclaration | methodDeclaration | constructorDeclaration {recoverWhile="class_body_part_recover"}




moduleBody ::= moduleBodyPart+  {pin=1}
private moduleBodyPart ::=    localVarDeclarationList | moduleMethodDeclaration  {recoverWhile="class_body_part_recover"}


classBody ::= '{' classBodyPart* '}' {pin=1}
private classBodyPart ::= fieldDeclaration | methodDeclaration | constructorDeclaration {recoverWhile="class_body_part_recover"}
private class_body_part_recover ::= !(ppToken | metaKeyWord | 'dynamic' | 'function' | 'inline' | 'override' | 'private' | 'public' | 'static' | 'var' | 'final' | '}' | 'macro' | 'class' | 'enum' | 'abstract' | 'typedef' | 'extern' | 'interface')

interfaceDeclaration ::= privateKeyWord? 'interface' componentName genericParam? inheritList? interfaceBody
{
    pin=3
    mixin="com.intellij.plugins.haxe.lang.psi.impl.AbstractHaxePsiClass"
    implements="com.intellij.plugins.haxe.lang.psi.HaxeClass"
}
interfaceBody ::= '{' interfaceBodyList? '}'
private interfaceBodyList ::= interfaceBodyPart+
private interfaceBodyPart ::= fieldDeclaration | methodDeclaration {recoverWhile="interface_body_part_recover"}
private interface_body_part_recover ::= !(ppToken | metaKeyWord | 'dynamic' | 'function' | 'inline' | 'override' | 'private' | 'public' | 'static' | 'var' | 'final' | '}' | 'class' | 'enum' | 'abstract' | 'typedef' | 'extern' | 'interface')

enumDeclaration ::= externOrPrivate? 'enum' componentName genericParam? enumBody
{
    pin=3
    mixin="com.intellij.plugins.haxe.lang.psi.impl.AbstractHaxePsiClass"
    implements="com.intellij.plugins.haxe.lang.psi.HaxeClass"
}
enumBody ::= '{' enumValueDeclaration* '}'

/*
 *  declarations
 */

methodModifier ::= 'extern' | 'final' | 'static' | 'inline' | 'dynamic' | 'override' | 'macro' | 'public' | 'private'
{
    implements="com.intellij.plugins.haxe.lang.psi.HaxePsiModifier"
}
abstractMethodModifier ::=  'extern' | 'override' | 'macro' | 'public' | 'private'
{
    implements="com.intellij.plugins.haxe.lang.psi.HaxePsiModifier"
}
fieldModifier ::= 'extern' | 'static' | 'inline' | 'dynamic' | 'override' | 'macro' | 'public' | 'private'
{
    implements="com.intellij.plugins.haxe.lang.psi.HaxePsiModifier"
}
mutabilityModifier ::= 'final' | 'var'

enumValueDeclaration ::= componentName genericParam? enumConstructorParameters? typeTag? ';'
{
    recoverWhile="enum_value_declaration_recovery"
    mixin="com.intellij.plugins.haxe.lang.psi.impl.HaxePsiFieldImpl"
    implements="com.intellij.plugins.haxe.lang.psi.HaxePsiField"
    methods=[returnType="typeTag"]
}

private enum_value_declaration_recovery ::= !(ID | '}' | 'class' | 'enum' | 'abstract' | 'typedef' | 'extern' | 'interface')

private enumConstructorParameters ::= parenthesizedParameterList
fieldDeclaration ::= (metadataDeclaration | fieldModifier)* mutabilityModifier componentName propertyDeclaration? typeTag? varInit? <<semicolonUnlessPrecededByStatement>>
{
    pin=3
    mixin="com.intellij.plugins.haxe.lang.psi.impl.HaxePsiFieldImpl"
    implements="com.intellij.plugins.haxe.lang.psi.HaxePsiField"
}
optionalFieldDeclaration ::= fieldModifier* mutabilityModifier '?' componentName propertyDeclaration? typeTag? varInit? <<semicolonUnlessPrecededByStatement>>
{
    pin=3
    mixin="com.intellij.plugins.haxe.lang.psi.impl.HaxePsiFieldImpl"
    implements="com.intellij.plugins.haxe.lang.psi.HaxePsiField"
}

localVarDeclarationList ::= (metadataDeclaration)* mutabilityModifier localVarDeclaration (',' localVarDeclaration)* <<semicolonUnlessPrecededByStatement>>{pin=2}
localVarDeclaration ::= componentName typeTag? varInit?
{
    recoverWhile="local_var_declaration_part_recover"
    mixin="com.intellij.plugins.haxe.lang.psi.impl.HaxePsiFieldImpl"
    implements="com.intellij.plugins.haxe.lang.psi.HaxePsiField"
}
private localVarDeclarationWithInit ::= componentName typeTag? varInit {extends=localVarDeclaration}
private local_var_declaration_part_recover ::= !('!' | ppToken | '(' | ')' | '++' | ',' | '-' | '--' | ';' | '[' | 'break' | 'case' | 'cast' | 'continue' | 'default' | 'do' | 'else' | 'false' | 'final' | 'for' | 'function' | 'if' | 'new' | 'null' | 'return' | 'super' | 'switch' | 'this' | 'throw' | 'true' | 'try' | 'untyped' | 'var' | 'while' | '{' | '}' | '~' | ID | OPEN_QUOTE | LITERAL_FLOAT | LITERAL_HEXADECIMAL | LITERAL_INTEGER | LITERAL_OCTAL | REG_EXP)

propertyDeclaration ::= '(' propertyAccessor ',' propertyAccessor ')'

propertyAccessor ::= 'null' | 'default' | 'dynamic' | 'never' | 'get' | 'set' | referenceExpression
{
    mixin="com.intellij.plugins.haxe.lang.psi.impl.HaxeReferenceImpl"
    implements="com.intellij.plugins.haxe.lang.psi.HaxeReference"
}

private functionCommonBody ::= blockStatement
                             | returnStatement
                             | throwStatement
                             | ifStatement
                             | forStatement
                             | whileStatement
                             | doWhileStatement
                             | switchStatement
                             | expression ';'
                             | ';'

private lambdaBody ::= blockStatement
                       | lamdaReturnStatement
                       | returnStatement
                       | throwStatement
                       | ifStatement
                       | forStatement
                       | whileStatement
                       | doWhileStatement
                       | expression

private localFunctionDeclarationAttribute ::= 'inline';

moduleMethodDeclaration ::=  (metadataDeclaration)* methodHeader 'untyped'? functionCommonBody
methodDeclaration ::= (metadataDeclaration | methodModifier)* methodHeader 'untyped'? functionCommonBody
{
    pin=3
    mixin="com.intellij.plugins.haxe.lang.psi.impl.HaxeMethodImpl"
    implements="com.intellij.plugins.haxe.lang.psi.HaxeMethod"
}
private methodHeader ::= 'function' methodDeclarator typeTag?
private methodDeclarator ::= componentName genericParam? parenthesizedParameterList

constructorDeclaration ::= (metadataDeclaration | methodModifier)* constructorHeader 'untyped'? functionCommonBody {pin=3 elementType="methodDeclaration"}
private constructorHeader ::= 'function' constructorDeclarator typeTag? {elementType="methodHeader"}
private constructorDeclarator ::= constructorName genericParam? parenthesizedParameterList {elementType="methodDeclarator"}
constructorId ::= 'new' {elementType="identifier"}
constructorName ::= constructorId {elementType="componentName"}

localFunctionDeclaration ::= localFunctionDeclarationAttribute? localFunctionHeader 'untyped'? functionCommonBody
{
    pin=2
    mixin="com.intellij.plugins.haxe.lang.psi.impl.HaxeMethodImpl"
    implements="com.intellij.plugins.haxe.lang.psi.HaxeMethod"
}
private localFunctionHeader ::= 'function' localFunctionDeclarator typeTag?
private localFunctionDeclarator ::= componentName? genericParam? parenthesizedParameterList

private arrowFunctionParameterList ::= openParameterList | parenthesizedParameterList
private arrowFunctionExpression ::=  arrowFunctionParameterList '->' lambdaBody {pin=3}

/*
 *
 */

varInit ::= '=' expression {pin=1}
parameter ::= optionalMark? componentName typeTag? varInit?
{
mixin="com.intellij.plugins.haxe.lang.psi.impl.HaxeParameterPsiMixinImpl"
implements="com.intellij.plugins.haxe.lang.psi.HaxeParameterPsiMixin"
}

// An open parameter can't have all of the type and init info.  Plus, it makes the parser *very* *very* slow in some circumstances.
openParameterList ::=  componentName  {extends=parameterList}
private parenthesizedParameterList ::= '(' parameterList ')'

parameterList ::= (parameter (',' parameter)*)?
{
    recoverWhile="parameterListRecovery"
    mixin="com.intellij.plugins.haxe.lang.psi.impl.HaxeParameterListPsiMixinImpl"
    implements="com.intellij.plugins.haxe.lang.psi.HaxeParameterListPsiMixin"
}
private parameterListRecovery ::= !('(' | ')')  // Open parens are allowable in arrow function arguments.

private arrowFunctionLiteral ::= arrowFunctionExpression
private arrowFunctionTypeLiteral ::= arrowFunctionDeclaration
private keywordFunctionLiteral ::= 'function' componentName? parenthesizedParameterList typeTag? 'untyped'? lambdaBody {pin=2}
functionLiteral ::= keywordFunctionLiteral | arrowFunctionLiteral

arrayLiteral ::= '[' (expressionList ','?)? ']'
{
mixin="com.intellij.plugins.haxe.lang.psi.impl.HaxeReferenceImpl"
implements="com.intellij.plugins.haxe.lang.psi.HaxeReference"
}
mapLiteral ::= '[' (mapInitializerStatement | mapInitializerExpressionList) ']'
{
    pin=2
    mixin="com.intellij.plugins.haxe.lang.psi.impl.HaxeReferenceImpl"
    implements="com.intellij.plugins.haxe.lang.psi.HaxeReference"
}

optionalMark ::= '?'
functionType ::= newFunctionType | oldFunctionType
functionReturnType ::= typeWrapper

private typeWrapper ::= functionType | typeOrAnonymous

private newFunctionType ::= '(' functionArgumentsList ')' '->' functionReturnType {pin=4}
private functionArgumentsList ::= [!')' functionArgument (',' functionArgument)*]
functionArgument ::= optionalFunctionTypeWithoutName | namedTypeOrAnonymous | namedFunctionType
private namedTypeOrAnonymous ::= [optionalMark] [componentName ':'] typeWrapper
private namedFunctionType ::= [optionalMark] [componentName ':'] functionType
private optionalFunctionTypeWithoutName ::= optionalMark '(' functionType ')' {pin=3}

private oldFunctionType ::= oldFunctionTypeArgumentsList functionReturnType {pin=2}
private oldFunctionTypeArgumentsList ::= ( oldFunctionTypeArgument '->')+
oldFunctionTypeArgument ::= optionalMark? ('(' functionType ')' | typeOrAnonymous) {elementType="functionArgument" pin(".*")=3}

// /////////////////////////////////////////////////////////////////////////////////////////
/*
 * Haxe and Java have this backward from each other.
 *
 * Haxe PSI type:                      Corresponding Java PSI Type:
 * =======================             =============================
 * TYPE_PARAM..........................PsiTypeParameterList
 * TYPE_LIST...........................n/a
 * TYPE_LIST_PART......................PsiTypeParameter
 *
 * There is a PsiType class but its not an element of the PSI.
 * There is a PsiTypeElement class that /is/ part of the tree, though it's pretty low-level.
 *
 */

typeTag ::= ':' typeWrapper
//TODO handle  multiple >>
//TODO test
//typeParam ::= OPERATOR_LESS typeList OPERATOR_GREATER
typeParam ::= '<' typeList '>'
//typeParam ::= '<' typeList  <<handleMultipleGtSymbols>>
{
    mixin="com.intellij.plugins.haxe.lang.psi.impl.HaxeTypeParamPsiMixinImpl"
    implements="com.intellij.plugins.haxe.lang.psi.HaxeTypeParamPsiMixin"
}
typeList ::= typeListPart (',' typeListPart)*
//TODO Test
//genericParam ::= OPERATOR_LESS genericListPart (',' genericListPart)* OPERATOR_GREATER
genericParam ::= '<' genericListPart (',' genericListPart)* '>'
genericListPart ::= regularGenericListPart | constGenericListPart
{
    mixin="com.intellij.plugins.haxe.lang.psi.impl.AbstractHaxeNamedComponent"
    implements="com.intellij.plugins.haxe.lang.psi.HaxeComponent"
}
private regularGenericListPart ::= componentName (':' ('(' typeList ')' | typeListPart))? {pin=2}
// constGenericListPart is only available when the macroMember is '@:const' (constMeta).  It's only useful in macros.
// We can't use constMeta here until the lexer returns a string for macros instead of META_ID.
private constGenericListPart ::= constantExpression (':' ('(' typeList ')' | typeListPart))? {pin=2}

typeListPart ::= typeWrapper | literalExpression
{
    mixin="com.intellij.plugins.haxe.lang.psi.impl.HaxeTypeListPartPsiMixinImpl"
    implements="com.intellij.plugins.haxe.lang.psi.HaxeTypeListPartPsiMixin"
}
type ::= referenceExpression qualifiedReferenceExpression* typeParam?
{
    pin = 1
    mixin="com.intellij.plugins.haxe.lang.psi.impl.HaxeTypePsiMixinImpl"
    implements="com.intellij.plugins.haxe.lang.psi.HaxeTypePsiMixin"
}
typeOrAnonymous ::= type | anonymousType

// The predicate !(objectLiteralElementList) is required to keep blockStatement from competing for precedence. Also need to override the statement pin value.
blockStatement ::= '{' !objectLiteralElementList statementList? '}'
{
    pin=3
    mixin="com.intellij.plugins.haxe.lang.psi.impl.HaxeBlockStatementPsiMixinImpl"
    implements="com.intellij.plugins.haxe.lang.psi.HaxeBlockStatementPsiMixin"
    extends="com.intellij.plugins.haxe.lang.psi.HaxeBlockStatementPsiMixin"
}
private statementList ::= (statement ';'?)+ {recoverWhile="statement_recovery"}
private statement_recovery ::= !('case' | 'default' | '}')

//https://haxe.org/manual/macro-reification-expression.html
// Expression Reification
macroArrayReification::= "$a" macroStatementWrapper
macroBlockReification::= "$b" macroStatementWrapper
macroIdentifierReification::= "$i" macroStatementWrapper
macroFieldReification::= "$p" macroStatementWrapper
macroDynamicReification::= "$v" macroStatementWrapper

macroExpReification::= "$e" macroStatementWrapper
macroShorthandExpReification::= DOLLAR "{" expression "}" // shorthand for $e / expression ?

//private dummy::= MACRO_EXP; //TODO mlo do we need this
private macroStatementWrapper ::= "{" expression "}"

macroExpressionReification::=  (metadataDeclaration)* (macroShorthandExpReification | macroArrayReification | macroBlockReification | macroIdentifierReification | macroFieldReification  | macroDynamicReification | macroExpReification  ) {pin=2} //todo add  this ? |  macroExpressionReification

//Class Reification
macroClassReification ::= 'macro' topLevelDeclaration

// type Reification
private TPath ::=  ':' simpleQualifiedReferenceExpression
private TFunction ::=  ':' arrowFunctionLiteral
private TAnonymous ::=  ':'  anonymousTypeBody  // TODO make a better expression
private TParent ::=  ':' type
private TExtend ::=  ':' '{>' type ',' identifier ',' type '}' // TODO make a better expression
private TOptional ::=  ':' '?' type

//OBS make sure ordering is correct
complexType ::= (TFunction | TAnonymous| TOptional | TParent | TExtend  | TPath)
//macroTypeReification ::= '('('macro' complexType) ')' | ('macro' complexType)
macroTypeReification ::= 'macro' complexType

//private macroStatement ::= blockStatement | notBlockStatement | macroExpression | statement
//private statement ::= macroExpression | blockStatement | notBlockStatement
private statement ::=  blockStatement | notBlockStatement
{
    pin=2
    mixin="com.intellij.plugins.haxe.lang.psi.impl.HaxeStatementPsiMixinImpl"
    implements="com.intellij.plugins.haxe.lang.psi.HaxeStatementPsiMixin"
}


private notBlockStatement ::= ('untyped' statement ';'?)
                            //support @pos before expression
                            | ('macro' (metadataDeclaration)* statement ';'?)
                            | macroClassReification
                            | localVarDeclarationList
                            | localFunctionDeclaration
                            | ifStatement
                            | forStatement
                            | whileStatement
                            | doWhileStatement
                            | returnStatement
                            | breakStatement
                            | continueStatement
                            | switchStatement
                            | throwStatement
                            | tryStatement
                            | expression

//TODO limit expression to CC expressions ?
conditionalCompilationStatement ::= (CONDITIONAL_COMPILATION_IF  expression) | (CONDITIONAL_COMPILATION_ELSEIF  expression) |CONDITIONAL_COMPILATION_END  | CONDITIONAL_COMPILATION_ERROR | CONDITIONAL_COMPILATION_LINE

forStatement ::= 'for' '(' iterableDeclaration ')' statement ';'?
{
    recoverWhile=forStatement_recover
    mixin="com.intellij.plugins.haxe.lang.psi.impl.HaxeForStatementPsiMixinImpl"
    implements="com.intellij.plugins.haxe.lang.psi.HaxeForStatementPsiMixin"
}
// XXX: Somehow or another, forStatement must derive from AbstractHaxeNamedComponent, or variable resolution will break.
private iterableDeclaration ::= forDeclaration 'in' iterable {pin=1 recoverWhile="iterable_decl_recovery"}
private iterable_decl_recovery ::= !(')')
private forDeclaration ::= keyValueIterator | componentName
iteratorkey ::= componentName
{
    mixin="com.intellij.plugins.haxe.lang.psi.impl.AbstractHaxeNamedComponent"
    implements="com.intellij.plugins.haxe.lang.psi.HaxeComponent"
}
iteratorValue ::= componentName
{
    mixin="com.intellij.plugins.haxe.lang.psi.impl.AbstractHaxeNamedComponent"
    implements="com.intellij.plugins.haxe.lang.psi.HaxeComponent"
}
keyValueIterator ::= iteratorkey fatArrowOperator iteratorValue



iterable ::= expression

doWhileBody ::= statement
whileStatement ::= 'while' '(' expression ')' doWhileBody ';'?
{
    methods=[guard="expression" body="doWhileBody"]
}
doWhileStatement ::= 'do' doWhileBody 'while' '(' expression ')' ';'
{
   methods=[guard="expression" body="doWhileBody"] implements="whileStatement"
}

private returnValue ::= objectLiteral
                      | statement
                      | expression
                      | parenthesizedExpression
                      | localVarDeclarationList   // Void value, so allowable, but not useful
lamdaReturnStatement ::= 'return' (returnValue)?
{
  implements="returnStatement"
}

returnStatement ::= 'return' (returnValue)? <<semicolonUnlessPrecededByStatement>>

breakStatement ::= 'break' ';'
continueStatement ::= 'continue' ';'

throwStatement ::= 'throw' expression ';'?

switchStatement ::= 'switch' expression switchBlock {pin=2}
switchBlock ::= '{' (switchCase | defaultCase)* '}'

switchCaseBlock ::= (literalExpression <<semicolonUnlessPrecededByStatement>>) | statementList
switchCase ::= 'case' switchCaseExpr (',' switchCaseExpr)* guard? ':' switchCaseBlock? {pin=1 recoverWhile="switch_case_recover"}
switchCaseExpr ::= (switchCaseExtractor | switchCaseCaptureVar | expression) (bitOperation switchCaseExpr)* {pin=1} // Should NOT be named Expression, because it should not be an expression.

switchCaseExtractor ::= switchCaseObjectExtractor | switchCaseVariableCapture
switchCaseObjectExtractor ::= identifier  '(' expression '=>' expression ')' {pin=4 extends="expression"}
switchCaseVariableCapture ::= callOrArrayAccess '=>' expression  {pin=2 extends="expression"}
// This rule is superseded by localVarDeclarationList (in one of its degenerate configurations), as part of expression.
switchCaseCaptureVar ::= mutabilityModifier+ componentName varInit? {pin=2 extends="localVarDeclaration"}
private switch_case_recover ::= !('case' | 'default' | '}' | ID)
defaultCase ::= 'default' ':' switchCaseBlock? {pin=2 extends="switchCase"}

guard ::= 'if' '(' expression ')'
private guard_recovery ::= !('(' | ')' | '{')
guardedStatement ::= statement
elseStatement ::= 'else' statement
ifStatement ::= guard guardedStatement (';'? elseStatement)? ';'? {pin=2}

tryStatement ::= 'try' statement ';'? catchStatement*
catchStatement ::= 'catch' '(' parameter ')' statement ';'?

mapInitializerForStatement ::= 'for' '(' componentName 'in' iterable ')' (mapInitializerExpression | mapInitializerStatement)
{
    pin=7
    extends=forStatement
    methods=[mapInitializer="expression"]
    mixin="com.intellij.plugins.haxe.lang.psi.impl.HaxeForStatementImpl"
}
mapInitializerWhileStatement ::= 'while' '(' expression ')' (mapInitializerExpression | mapInitializerStatement)
{
    pin=5
    extends=whileStatement
    methods=[condition="expression[0]"
    mapInitializer="expression[1]"]
    mixin="com.intellij.plugins.haxe.lang.psi.impl.HaxeWhileStatementImpl"
}
private mapInitializerStatement ::= mapInitializerForStatement
                                  | mapInitializerWhileStatement
/*
 * expressions
 */

// Map initializer expressions are not part of the generalized expression type.
mapInitializerExpressionList ::= mapInitializerExpression (',' mapInitializerExpression)* ','? {recoverWhile=expression_list_recover}
mapInitializerExpression ::= expression fatArrowOperator expression {pin=2}
private fatArrowOperator ::= '=>'

expressionList ::= forStatement | whileStatement | (expression (',' expression)*) ','? {recoverWhile="expression_list_recover"}
private expression_list_recover ::= !(')' | ']' | '}')

private expression_recover ::= !('!' | '!=' | '%' | '%=' | '&&' | '&' | '&=' | '(' | ')' | '*' | '*=' | '+' | '++' | '+=' | ',' | '-' | '--' | '-=' | '.' | '...' | '/' | '/=' | ':' | ';' | '<' | '<<' | '<<=' | '<=' | '=' | '==' | '>' | shiftRightOperator | unsignedShiftRightOperator | '>=' | shiftRightAssignOperator | unsignedShiftRightAssignOperator | '?' | metaKeyWord | '[' | ']' | '^' | '^=' | 'break' | 'case' | 'cast' | 'catch' | 'continue' | 'default' | 'do' | 'dynamic' | 'else' | 'extern' | 'false' | 'final' | 'for' | 'function' | 'if' | 'inline' | 'new' | 'null' | 'override' | 'private' | 'public' | 'return' | 'static' | 'super' | 'switch' | 'this' | 'throw' | 'true' | 'try' | 'untyped' | 'var' | 'while' | '{' | '|' | '|=' | '||' | '}' | '~' | ID | LITERAL_FLOAT | LITERAL_HEXADECIMAL | LITERAL_INTEGER | LITERAL_OCTAL | OPEN_QUOTE | CLOSING_QUOTE | META_ID | REG_EXP | LONG_INTERPOLATION_ENTRY_END | '=>' | OPERATOR_FAT_ARROW)

//(metadataDeclaration)*
expression ::=
             (
             | assignExpression
             | iteratorExpression
             | ternaryExpression
             | logicOrExpression
             | logicAndExpression
             | compareExpression
             | bitwiseExpression
             | shiftExpression
             | additiveExpression
             | multiplicativeExpression
             | moduloExpression
             | isTypeExpression         // With Haxe 4.2, won't compile with prefix; lower than postfix or value.
             | prefixExpression
             | postfixExpression
             | valueExpression !suffixOperator !assignableOperator
             )
             { extraRoot=true recoverWhile=expression_recover}

assignExpression ::= expression assignOperation expression                    {pin=2 rightAssociative=true extends=binaryExpression}
isTypeExpression ::= expression isOperator (typeWrapper | literalExpression)  {pin=2  methods=[ leftExpression="/expression[0]" operator="isOperator"] }
iteratorExpression ::= expression iteratorOperator expression                 {pin=2  extends=binaryExpression }
ternaryExpression ::= expression questionOperator expression colonOperator expression
  {
    pin=2
    rightAssociative=true
    methods=[ guardExpression="/expression[0]"
              guardedExpression="/expression[1]"
              elseExpression="/expression[2]"]
  }
logicOrExpression ::= expression logicOrOperator expression                   { extends=binaryExpression }
logicAndExpression ::= expression logicAndOperator expression                 { extends=binaryExpression }
compareExpression ::= expression compareOperation expression                  { extends=binaryExpression }
bitwiseExpression ::= expression bitOperation expression                      { extends=binaryExpression }
shiftExpression ::= expression shiftOperator expression                       { extends=binaryExpression }
additiveExpression ::= expression additiveOperator expression                 { extends=binaryExpression }
multiplicativeExpression ::= expression multiplicativeOperator expression     { extends=binaryExpression }
moduloExpression ::= expression moduloOperator expression                     { extends=binaryExpression }
prefixExpression ::= (prefixOperator (postfixExpression | valueExpression))
                   | (assignableOperator assignableValueExpression)           { extends=unaryExpression }
postfixExpression ::= (assignableValueExpression assignableOperator)
                   | notSuffixExpression                                      { extends=unaryExpression }
notSuffixExpression ::= valueExpression suffixOperator                        { extends=postfixExpression }
valueExpression ::= value

// These fake rules won't be in the parser, but the PSI will contain a HaxeBinaryExpression class
// which will be the superclass of the extending classes in the PSI.
fake binaryExpression ::= expression* operator+ {
  methods=[leftExpression="/expression[0]" rightExpression="/expression[1]" operator="/operator[0]"]
}
fake unaryExpression ::= expression* operator+ {
  methods=[expression="/expression[0]" operator="/operator[0]"]
}
private assignableValueExpression ::= referenceExpression (qualifiedReferenceExpression)* arrayAccessExpression*


// Be careful when changing the ordering of the 'or' clauses here.  It matters!!
// In particular, callFunctionLiteral must come before (literalExpression qualifiedReferenceTail?).
// If callOrArrayAccess comes before literalExpression, then referenceExpression (as part of callOrArrayAccess)
// will take the first identifier and the rest will not match properly.
private value ::= ('untyped' expression)
                | 'macro' expression

                | callFunctionLiteral
                | immediateArrayAccess
                | macroTypeReification
                | (macroExpressionReification qualifiedReferenceTail?)
                | (literalExpression qualifiedReferenceTail?)
                | objectLiteral
                | functionType

                //TODO  limit "switchCaseExtractor" to only switch case
                // problem is that a switchCaseExtractor expression can be within other expressions used in the
                // "case" expression so some sort of recursion must be supported  for it to be pares correctly
                | switchCaseExtractor

                | callOrArrayAccess
                | ifStatement
                | (castExpression qualifiedReferenceTail?)
                | newExpressionOrCall
                | parenthesizedExpressionOrCall  // Seems redundant with callOrArrayAccess
                | tryStatement
                | switchStatement
                | throwStatement
                | localVarDeclarationWithInit
                | referenceExpression
                | thisExpression
                | superExpression
{pin=2}

literalExpression ::= LITERAL_INTEGER | LITERAL_HEXADECIMAL | LITERAL_OCTAL | LITERAL_FLOAT
                    | regularExpressionLiteral
                    | 'null' | 'true' | 'false'
                    | functionLiteral
                    | mapLiteral
                    | arrayLiteral
                    | objectLiteral
                    | stringLiteralExpression
                    | blockStatement
{
    name="literal expression"
    mixin="com.intellij.plugins.haxe.lang.psi.impl.HaxeReferenceImpl"
    implements="com.intellij.plugins.haxe.lang.psi.HaxeReference"
}


constantExpression ::= LITERAL_INTEGER | LITERAL_HEXADECIMAL | LITERAL_OCTAL | LITERAL_FLOAT
                             | regularExpressionLiteral
                             | 'null' | 'true' | 'false'
                             |stringLiteralExpression
{
    name="constant expression"
    mixin="com.intellij.plugins.haxe.lang.psi.impl.HaxeReferenceImpl"
    implements="com.intellij.plugins.haxe.lang.psi.HaxeReference"
}


stringLiteralExpression ::=  quotationStringExpression | apostropheStringExpression
{
    pin=1
    mixin="com.intellij.plugins.haxe.lang.psi.impl.HaxeReferenceImpl"
    implements="com.intellij.plugins.haxe.lang.psi.HaxeReference"
}
private apostropheStringExpression ::= OPEN_APOSTROPHE (REGULAR_STRING_PART | STRING_ESCAPE | shortStringInterpolationEntry | longStringInterpolationEntry )* CLOSING_APOSTROPHE
private quotationStringExpression ::= OPEN_QUOTE (REGULAR_STRING_PART | STRING_ESCAPE)* CLOSING_QUOTE


shortStringInterpolationEntry ::= SHORT_INTERPOLATION_ENTRY (thisExpression | referenceExpression) {pin=1}
longStringInterpolationEntry ::= LONG_INTERPOLATION_ENTRY_START expression LONG_INTERPOLATION_ENTRY_END {pin=1 recoverWhile="long_Interpolation_entry_recover"}
private long_Interpolation_entry_recover ::= !(';' | '"' | "'" | REGULAR_STRING_PART)

regularExpressionLiteral ::= REG_EXP
{
    extends="literalExpression"
    mixin="com.intellij.plugins.haxe.lang.psi.impl.HaxeRegularExpressionImpl"
    implements="com.intellij.plugins.haxe.lang.psi.HaxeRegularExpression"
}

private parenthesizedExpressionOrCall ::= parenthesizedExpression qualifiedReferenceTail?
parenthesizedExpression ::= '(' (typeCheckExpr | macroTypeReification | expression | statement )  ')' {name="expression"}

private typeCheckOperator ::= ':'
typeCheckExpr ::= expression typeCheckOperator typeWrapper
{
    mixin="com.intellij.plugins.haxe.lang.psi.impl.HaxeClassReferenceImpl"
    implements="com.intellij.plugins.haxe.lang.psi.HaxeReference"
}

private newExpressionOrCall ::= newExpression qualifiedReferenceTail?
private qualifiedReferenceTail ::=  qualifiedReferenceExpression  (callExpression | arrayAccessExpression | qualifiedReferenceExpression)*

private callFunctionLiteral ::= functionLiteral callExpression
private callOrArrayAccess ::= (referenceExpression | thisExpression | superExpression | parenthesizedExpression ) (callExpression | arrayAccessExpression | qualifiedReferenceExpression)*
private immediateArrayAccess ::= arrayLiteral arrayAccessExpression

left callExpression ::= '(' expressionList? ')'
{
    name="function call"
    mixin="com.intellij.plugins.haxe.lang.psi.impl.HaxeReferenceImpl"
    implements="com.intellij.plugins.haxe.lang.psi.HaxeReference"
}
left arrayAccessExpression ::= '[' expression ']'
{
    name="array access"
    mixin="com.intellij.plugins.haxe.lang.psi.impl.HaxeReferenceImpl"
    implements="com.intellij.plugins.haxe.lang.psi.HaxeReference"
}

referenceExpression ::= identifier
{
    mixin="com.intellij.plugins.haxe.lang.psi.impl.HaxeReferenceImpl"
    implements="com.intellij.plugins.haxe.lang.psi.HaxeReference"
}
left qualifiedReferenceExpression ::= '.' identifier {elementType="referenceExpression" pin=2}
private simpleQualifiedReferenceExpression ::= referenceExpression qualifiedReferenceExpression * { elementType="referenceExpression"}
//TODO  do we need macroIdentifierReification here anymore ?
componentName ::=  macroIdentifierReification | identifier
{
    mixin="com.intellij.plugins.haxe.lang.psi.impl.HaxeNamedElementImpl"
    implements="com.intellij.plugins.haxe.lang.psi.HaxeNamedElement"
}
identifier ::= ID | MACRO_ID
{
    name="identifier"
    mixin="com.intellij.plugins.haxe.lang.psi.impl.HaxeIdentifierPsiMixinImpl"
    implements="com.intellij.plugins.haxe.lang.psi.HaxeIdentifierPsiMixin"
}

thisExpression ::= 'this'
{
    mixin="com.intellij.plugins.haxe.lang.psi.impl.HaxeReferenceImpl"
    implements="com.intellij.plugins.haxe.lang.psi.HaxeReference"
}

superExpression ::= 'super'
{
    mixin="com.intellij.plugins.haxe.lang.psi.impl.HaxeReferenceImpl"
    implements="com.intellij.plugins.haxe.lang.psi.HaxeReference"
}

// XXX - This could be callExpression, and it makes sense that newExpression would extend/implement callExpression,
//       but that affects a lot of code and is best not attempted just before a release...
//private newCallExpression ::= '(' expressionList? ')'
//newExpression ::= 'new' type newCallExpression
private newExpressionArgumentsList ::= '(' [!')' expression (',' expression)*] ')' {pin(".*")=1}
newExpression ::= 'new' type newExpressionArgumentsList
{
    pin=2
    recoverWhile="expression_recover"
    mixin="com.intellij.plugins.haxe.lang.psi.impl.HaxeReferenceImpl"
    implements="com.intellij.plugins.haxe.lang.psi.HaxeReference"
}

castExpression ::= 'cast' (('(' expression ',' typeWrapper ')')  | expression)
{
    mixin="com.intellij.plugins.haxe.lang.psi.impl.HaxeClassReferenceImpl"
    implements="com.intellij.plugins.haxe.lang.psi.HaxeReference"
}

inheritList ::= inherit (','? inherit)*

private inherit ::= extendsDeclaration | implementsDeclaration
{
    pin=1
    recoverWhile="inherit_recover"
    mixin="com.intellij.plugins.haxe.lang.psi.impl.HaxeInheritPsiMixinImpl"
    implements="com.intellij.plugins.haxe.lang.psi.HaxeInheritPsiMixin"
}
private inherit_recover ::= !(',' | '{' | 'extends' | 'implements')

extendsDeclaration ::= 'extends' type
{
    pin=1
    mixin="com.intellij.plugins.haxe.lang.psi.impl.HaxeInheritImpl"
    implements="com.intellij.plugins.haxe.lang.psi.HaxeInherit"
}
implementsDeclaration ::= 'implements' type
{
    pin=1
    mixin="com.intellij.plugins.haxe.lang.psi.impl.HaxeInheritImpl"
    implements="com.intellij.plugins.haxe.lang.psi.HaxeInherit"
}


//       The only difference between anonymous types and object literals are that object literals have values in their type tags.
//       See parse_block_elt and parse_anonymous in grammar.mly (Haxe compiler sources).

anonymousType ::= anonymousTypeBody // Yes, we need two levels to keep parity with other types.
{
    mixin="com.intellij.plugins.haxe.lang.psi.impl.AnonymousHaxeTypeImpl"
    implements="com.intellij.plugins.haxe.lang.psi.HaxeClass"
}

anonymousTypeBody ::= anonymousTypeWithEmptyBody | regularAnonymousTypeBody
private anonymousTypeWithEmptyBody ::= '{' '}' {pin=2}
private regularAnonymousTypeBody ::= '{' anonymousTypeBodyContents '}' {pin=2}
private anonymousTypeBodyContents ::= extendedAnonymousTypeBody | simpleAnonymousTypeBody | interfaceBodyList
private extendedAnonymousTypeBody ::= typeExtendsList (',' anonymousTypeFieldList)? (sep anonymousInterfaceBodyList)?
private anonymousInterfaceBodyList ::= (interfaceBodyPart | optionalFieldDeclaration)+  {recoverWhile="interface_body_part_recover"}
private simpleAnonymousTypeBody ::= anonymousTypeFieldList (sep anonymousInterfaceBodyList)?
typeExtendsList ::= '>' type (',' '>' type)* {pin=1}
//field lists can end with "," in haxe unlike  for instance java
anonymousTypeFieldList ::= anonymousTypeField (',' anonymousTypeField)* ','? {recoverWhile="object_literal_part_recover" pin=1}
private sep ::= ',' | ';'
anonymousTypeField ::= "?"? componentName typeTag
{
    pin=3
    mixin="com.intellij.plugins.haxe.lang.psi.impl.HaxePsiFieldImpl"
    implements="com.intellij.plugins.haxe.lang.psi.HaxePsiField"
}

// Do NOT genericize objectLiteral by making objectLiteralElementList optional.  Doing so
// makes blockStatement be overridden by objectLiteral in return statements.
private emptyObjectLiteral ::= '{' '}' {name="Object Literal"}
private nonEmptyObjectLiteral ::= '{' objectLiteralElementList '}' {pin=2}
objectLiteral ::= nonEmptyObjectLiteral | emptyObjectLiteral

private objectLiteralElementList ::= objectLiteralElement (',' objectLiteralElement)* ','? {pin=1 recoverWhile="object_literal_list_recover"}
private object_literal_list_recover ::= !('}')

objectLiteralElement ::= (identifier | stringLiteralExpression) ':' expression {pin=2 recoverWhile="object_literal_part_recover"}
private object_literal_part_recover ::= !(',' | '}')
