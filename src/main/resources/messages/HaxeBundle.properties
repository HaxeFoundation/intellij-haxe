#
# Copyright 2000-2013 JetBrains s.r.o.
# Copyright 2014-2014 AS3Boyan
# Copyright 2014-2014 Elias Ku
# Copyright 2017-2020 Eric Bishton
# Copyright 2017-2018 Ilya Malanin
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#
haxe.title=Haxe
haxe.project=Haxe project
haxe.module.type.name=Haxe Module
haxe.module.type.description=Encapsulates core functionality for building <b>Haxe</b> applications. \
  Support running Haxe application in <b>Neko</b> virtual machine.
haxe.sdk.name.presentable=Haxe toolkit
runner.configuration.name=Haxe Application
haxe.sdk.name.suggest=Haxe {0}
haxe.run.exclude.compile=&Skip compilation
haxe.main.class=Main &class:
haxe.run.parameters=&Parameters:
haxe.run.module=&Module\:
haxe.run.target=&Target:
haxe.compiler.description=Haxe Compiler
haxe.language.id=Haxe
haxe.file.type.name=Haxe
haxe.file.type.description=Haxe Files
no.sdk.for.module=No SDK for module\: {0}
haxe.module.editor.haxe=Haxe
no.module.for.run.configuration=No module for Run Configuration {0}
action.create.new.class=New Haxe Class
progress.creating.class=Creating Class {0}
haxe.run.wrong.target=Wrong target {0}\! You can run only Neko, Flash or JavaScript.
haxe.run.bad.neko.bin.path=No Neko\! Select Neko binary for you Haxe sdk.
choose.haxe.main.class=Choose Haxe Main class
neko.executable=&Neko executable\:
haxe.color.settings.description.line.comment=Line comment
haxe.color.settings.description.block.comment=Block comment
haxe.color.settings.description.doc.comment=Documentation comment
haxe.color.settings.description.keyword=Keyword
haxe.color.settings.description.number=Number
haxe.color.settings.description.string=String
haxe.color.settings.description.operator=Operator
haxe.color.settings.description.parenths=Parenths
haxe.color.settings.description.brackets=Brackets
haxe.color.settings.description.braces=Braces
haxe.color.settings.description.comma=Comma
haxe.color.settings.description.dot=Dot
haxe.color.settings.description.semicolon=Semicolon
haxe.color.settings.description.bad.character=Bad character
haxe.color.settings.description.class=Class
haxe.color.settings.description.interface=Interface
haxe.color.settings.description.instance.member.variable=Instance member variable
haxe.color.settings.description.instance.member.function=Instance member function
haxe.color.settings.description.static.member.function=Static member function
haxe.color.settings.description.static.member.variable=Static member variable
haxe.color.settings.description.parameter=Parameter
haxe.color.settings.description.local.variable=Local variable
haxe.output.file.name=&Output file name\:
haxe.output.folder=Output &folder\:
cannot.resolve.reference=Can't resolve reference
flex.sdk.not.specified=Flex SDK is required for Flash applications debugging. Please configure Flex SDK in Project Structure dialog.
flex.sdk.not.found=Flex SDK ''{0}'' not found. Please configure Flex SDK in Project Structure dialog.
haxe.proper.debug.targets=You can debug only Flash, AIR, or HXCPP targets\!
haxe.break.point.title=Haxe Breakpoints
flex.sdk.label=&Flex SDK for Flash applications debugging:
haxe.run.file.to.run=Custom file to &run
nme.nmml=NMML
nme.nmml.description=NMML project file
haxe.configuration.use.hxml.to.build=&HXML
haxe.configuration.use.nmml.to.build=&NMML
haxe.configuration.hxml.file=HXML file\:
haxe.configuration.nmml.file=NMML file\:
haxe.configuration.openfl.file=OpenFL file\:
haxe.run.no.module=No module for configuration\: {0}
haxe.run.select.custom.file=Select file to launch in case of using HXML
haxe.run.do.not.select.custom.file=You cannot launch custom file in case of using NME
haxe.run.do.not.select.custom.executable=You cannot use custom executable in case of using NME
overrides.method.in=Overrides method ''{0}'' in ''{1}''
implements.method.in=Implements method ''{0}'' in ''{1}''
haxe.override.method=Choose method to override
haxe.implement.method=Choose method to implement
fields.to.generate.constructor=Constructor
fields.to.generate.getters=Select Fields to Generate Getters
fields.to.generate.setters=Select Fields to Generate Setters
fields.to.generate.getters.setters=Select Fields to Generate Getters and Setters
haxe.configuration.use.custon.properties=Haxe &Compiler\:
haxelib.executable=&Haxelib executable\:
haxe.compile.with=Compile with\:
sources.root.detector.sources.name=Library sources
sources.root.detector.classes.name=Library classes
create.nmml.file.action=NMML File
create.nmml.file.action.description=Create NMML File
haxe.unresolved.type=Unresolved type
choose.class.to.import.title=Choose Class To Import
add.import.multiple.candidates={0} ? (multiple choices...) Alt+Enter
autodetected.source.root.type=Haxe
macro.haxe.array.variable=haxeArrayVariable()
macro.haxe.variable.name=haxeSuggestVariableName()
macro.haxe.index.name=haxeSuggestIndexName()
livetemplate.description.iter=Iterate (for..in)
livetemplate.description.itar=Iterate elements of array
livetemplate.description.ritar=Iterate elements of array in reverse order
haxe.surrounder.if=if
haxe.surrounder.if.else=if / else
haxe.surrounder.while=while
haxe.surrounder.do.while=do / while
haxe.surrounder.try.catch=try / catch
haxe.settings.name=Haxe
haxe.conditional.compilation.defined.macros=Defined Haxe conditional compilation macros\:
haxe.conditional.compilation.title=Define Haxe Macros
haxe.conditional.compilation.macros=Conditional compilation macros\:
haxe.color.settings.description.conditional.compilation=Conditionally non-compiled
haxe.color.settings.description.unparseable.data=Unparseable data
haxe.conditional.compilation.setting=Project Macros\:
haxe.settings.edit=Edit
haxe.intention.undefine=Undefine flag ''{0}''
haxe.intention.define=Define flag ''{0}''
quick.fixes.family=Haxe Quick Fixes
haxe.color.settings.description.conditional.compilation.defined.flag=Defined flag
haxe.color.settings.description.conditional.compilation.undefined.flag=Undefined Flag
haxe.color.settings.description.metadata=Metadata
haxe.project.reparsing=Applying new compiler macros...
refactoring.introduce.selection.error=Cannot perform refactoring using selected element(s)
refactoring.introduce.variable.dialog.title=Introduce Variable
install.flex.plugin=Please install Flex plugin to debug Flash target\!
enable.flex.plugin=Please enable Flex plugin to debug Flash target\!
hxcpp.port.label=HXCPP Debugging Port\:
hxcpp.debugging.description=Creates debug server that communicates with application across protocol supported by hxcpp.DebugSocket
haxe.inspections.group.name=Haxe
haxe.inspections.nme.build.directory=NMML Build Directory Inspection
haxe.inspections.nme.build.directory.descriptor=You need to provide separate build directories for release and debug builds
haxe.inspections.nme.build.directory.fix.name=Create debug tag
haxe.nme.arguments=NME arguments\:
haxe.openfl.arguments=OpenFL arguments\:
inspections.group.name=Haxe
inspections.semantic.annotation.group.name=Semantic Annotations
haxe.inspections.semantic.annotator.name=Semantic Annotator
haxe.inspections.incompatible.type.checks.inspection.name=Incompatible Type Check
haxe.inspections.incompatible.initialization.inspection.name=Local Variable Initialization
haxe.inspections.incompatible.initialization.inspection.description=Checks expression (value) type against declared variable type.
haxe.inspection.unused.import.name=Unused import statement
haxe.inspections.final.field.is.initialized.inspection.name=Final Field is Initialized
haxe.inspections.final.field.is.initialized.inspection.description=Checks whether fields declared final (or marked with <code>@:final</code> metadata) have been initialized properly.
haxe.inspections.field.redefinition.inspection.name=Field Redefinition
haxe.inspections.field.redefinition.inspection.description=Checks whether an inherited field has been redefined within a child class.
haxe.inspections.property.accessor.valid.name=Property Accessor Validity
haxe.inspections.property.accessor.valid.description=Checks whether property accessors, when they exist, match the property's access declaration.
haxe.inspections.property.cannot.be.final.name=Property Cannot Be Final
haxe.inspections.property.cannot.be.final.description=Checks whether a property is declared final or marked with <code>@:final</code> metadata.
haxe.inspections.property.is.not.a.real.variable.name=Property is Not a Real Variable
haxe.inspections.property.is.not.a.real.variable.description=Checks whether a property initialization is disallowed because no underlying variable will be allocated by the compiler.  Based upon its access declaration a property may not need an underlying variable, thus none will be created unless the property is marked with <code>@:isVar</code> metatdata. 
haxe.inspections.property.accessor.existence.name=Property Accessor Existence
haxe.inspections.property.accessor.existence.description=Checks whether property accessors (getter and/or setter) have been defined properly, given the property's access declaration.
haxe.inspections.type.name.casing.name=Type Name Correctness
haxe.inspections.type.name.casing.description=Checks that type names follow proper casing convention; whether they begin with a upper case letter.
haxe.inspections.duplicate.class.modifier.name=Duplicate Class Modifiers
haxe.inspections.duplicate.class.modifier.description=Checks whether duplicate modifiers (e.g. <code>private</code>, <code>final</code>, <code>extern</code>) have been applied to a class declaration.
haxe.inspections.duplicated.field.name=Duplicate Class Members
haxe.inspections.duplicated.field.description=Checks whether a field or method name has been declared more than once in a class.
haxe.inspections.superclass.type.compatibility.name=Superclass Type Compatibility
haxe.inspections.superclass.type.compatibility.description=Checks whether a class extends a correct type and not itself.
haxe.inspections.superinterface.type.compatibility.name=Superinterface Type Compatibility
haxe.inspections.superinterface.type.compatibility.description=Checks whether the declared interfaces implemented by a class are really interfaces.
haxe.inspections.missing.interface.methods.name=Interface Method Existence
haxe.inspections.missing.interface.methods.description=Checks whether all methods required by a declared interface are implemented by the class.
haxe.inspections.interface.methods.signature.name=Interface Method Signature Compatibility
haxe.inspections.interface.methods.signature.description=Checks whether the signature for a method implementation matches the interface method declaration.
haxe.inspections.inherited.interface.method.signature.name=Inherited Interface Method Signature Compatibility
haxe.inspections.inherited.interface.method.signature.description=Checks whether the signature from an inherited method implementation matches the interface method declaration.
haxe.inspections.missing.type.tag.on.extern.or.interface.name=Missing Type Specifier
haxe.inspections.missing.type.tag.on.extern.or.interface.description=Checks whether types are specified in field (property, method) declarations for interfaces and <code>extern</code> classes.
haxe.inspections.initializer.on.optional.method.argument.name=Initializer For Optional Method Parameter
haxe.inspections.initializer.on.optional.method.argument.description=Checks whether a method parameter is marked optional (e.g. <code>?param</code>) when it has a default value declared.  Parameters with default values are already optional and don't need this marking.
haxe.inspections.is.type.expression.inspection.name='Is' Operator Type Correctness
haxe.inspections.is.type.expression.inspection.description=Checks that the type on the right-hand side of the 'is' operator is actually a type and not an expression.
haxe.inspections.is.type.expression.inspection.4dot1.compatible.name='Is' Operator compatibility for Haxe 4.1.x
haxe.inspections.is.type.expression.inspection.4dot1.compatible.description='Is' Operator Type Correctness warnings for Haxe compiler versions 4.1 and below. (Adds restrictions about where 'is' can be used.)
haxe.inspections.parameter.initializer.type.name=Parameter Default Initializer Compatibility
haxe.inspections.parameter.initializer.type.description=For (optional) parameters with default values, checks whether the expression type of the initializer matches (unifies with) the type, if specified, for the parameter and is a constant value.
haxe.inspections.parameter.ordering.name=Optional Parameter Ordering
haxe.inspections.parameter.ordering.description=Checks whether optional parameters come before non-optional parameters in a method declaration.
haxe.inspections.parameter.name.duplicated.name=Duplicate Parameter Name
haxe.inspections.parameter.name.duplicated.description=Checks that parameter names are unique for a given method.
haxe.inspections.method.override.name=Method Overrides
haxe.inspections.method.override.description=Checks whether methods that override a superclass method are marked correctly (using <code>override</code>), whether they incorrectly override static, final, or inline methods, and whether their visibility (<code>private</code>, <code>public</code>) differs.
haxe.inspections.method.signature.compatiblity.name=Overridden Method Signature Compatibility
haxe.inspections.method.signature.compatiblity.description=Checks that an overriding method's signature matches the superclass' method signature.
haxe.inspections.package.name.name=Package Name Correctness
haxe.inspections.package.name.description=Checks the package name for case correctness, and that the file in which it declared is located in the expected directory structure.
haxe.inspections.string.interpolation.quote.name=Interpolated String Quotes
haxe.inspections.string.interpolation.quote.description=Checks the quote types (<code>''</code> or <code>""</code>) for strings with embedded variables and/or code.
haxe.inspections.assignment.type.compatibility.name=Assignment Type Compatibility
haxe.inspections.assignment.type.compatibility.description=Checks whether the expression (value) being assigned matches the type of the variable it is being assigned to.
haxe.fix.optimize.imports=Optimize imports
haxe.inspection.unresolved.symbol=Unresolved symbol
haxe.inspection.deprecated.symbol=Deprecated symbol
haxe.inspection.preprocessor.symbol.name=Conditional Compilation (Preprocessing)
haxe.openfl.xmlproject=OpenFL Project XML \:
haxe.lookup.alias=alias for {0}

# HXML syntax support
hxml.language.id = HXML
hxml.file.type.name = HXML
hxml.file.type.description = Haxe Build Files
sdk.roots.multiple=Haxe SDK has multiple roots. This may lead to unexpected behavior.
sdk.roots.no.valid.root=Haxe SDK has no valid root. Set up or change SDK.

# HAXE tests

haxe.tests.runner.configuration.name=Haxe Tests
haxe.tests.run.module=&Module\:
haxe.tests.run.runner.class=&Runner Class\:

# HAXE semantic errors
haxe.semantic.type.required=Type required for extern classes and interfaces
haxe.semantic.overwritten.method.parameter.optional=Expected: ''{0}''. Parameter is declared as optional by superclass method ''{1}''.
haxe.semantic.overwritten.method.parameter.required=Expected: ''{0}''. Parameter is declared as required by superclass method ''{1}''.
haxe.semantic.implemented.method.parameter.optional=Expected: ''{0}''. Parameter is declared as optional by interface method ''{1}''.
haxe.semantic.implemented.method.parameter.required=Expected: ''{0}''. Parameter is declared as required by interface method ''{1}''.
haxe.semantic.method.parameter.optional.add=Declare parameter as optional
haxe.semantic.method.parameter.optional.remove=Remove "optional" mark from parameter declaration
haxe.semantic.method.parameter.too.many=Too many arguments (expected {0} but got {1})"
haxe.semantic.method.parameter.missing=Not enough arguments (expected {0} but got {1})"
haxe.semantic.method.parameter.mismatch=Type mismatch (Expected: ''{0}'' got: ''{1}'')
haxe.semantic.implemented.super.method.signature.differs=Signature of inherited method ''{0}'' declared by class ''{1}'' differs from declared by interface. Expected ''{2}'', got ''{3}''
haxe.semantic.static.field.override=Field ''{0}'' overrides a static field of a superclass.
haxe.semantic.variable.redefinition=Redefinition of variable ''{0}'' in subclass is not allowed. Previously declared at ''{1}''.
haxe.semantic.property.cant.be.final=Property can not be final
haxe.semantic.final.static.var.init=Static final variable ''{0}'' must be initialized
haxe.semantic.final.static.var.init.interface=Default values on interfaces are not allowed
haxe.semantic.statement.does.not.unify.with.asserted.type=Statement of type ''{0}'' does not unify with asserted type ''{1}.''
haxe.semantic.interface.error.message=Not an interface
haxe.semantic.parameter.default.type.should.be.constant=Parameter default type should be constant but was {0}
haxe.semantic.trying.to.change.an.immutable.value=Trying to change an immutable value.
haxe.semantic.incompatible.type.0.should.be.1=Incompatible type: {0} should be {1}
haxe.semantic.incompatible.return.type.0.should.be.1=Incompatible return type: {0} should be {1}
haxe.semantic.change.type=Change type
haxe.semantic.key.must.not.be.repeated.for.class.declaration={0} must not be repeated for class declaration
haxe.semantic.final.var.init=Final field ''{0}'' must be initialized immediately or in the constructor
haxe.semantic.cannot.assign.value.to.final.variable=Cannot assign value to 'final' variable.
haxe.semantic.class.does.not.allow.array.access={0} does not allow array access.
haxe.semantic.is.operator.type.not.supported=Unsupported type for ''is'' operator.
haxe.semantic.is.operator.rhs.must.be.type=Right-hand side of ''is'' operator must be a Type name.
haxe.semantic.is.operator.type.cannot.have.parameters=Type parameters are not supported for the ''is'' operator.
haxe.semantic.is.operator.lhs.cannot.be.complex.expression=Left-hand side of ''is'' operator cannot be a binary or ternary expression.
haxe.semantic.is.operator.4_1.lhs.cannot.be.assignment=Expression on left-hand side of ''is'' operator cannot be an assignment expression. (pre-4.2 semantics)
haxe.semantic.is.operator.4_1.lhs.cannot.be.var.init=Unparenthesized ''is'' expression cannot be used for variable initialization. (pre-4.2 semantics)
haxe.semantic.unparenthesized.is.expression.cannot.be.used.here.pre.4.2.semantics=Unparenthesized "is" expression cannot be used here. (pre-4.2 semantics)
haxe.semantic.is.expression.requires.double.parenthesis.when.used.as.a.guard.expression.pre.4.2.semantics="is" expression requires double parenthesis when used as a guard expression. (pre-4.2 semantics)
haxe.semantic.unparenthesized.is.expression.cannot.be.used.here=Unparenthesized "is" expression cannot be used here.
haxe.semantic.inspection.message.expression.that.contains.string.interpolation.should.be.wrapped.with.single.quotes=An expression that contains string interpolation should be wrapped with single-quotes.

# HAXE fixes
haxe.quickfix.make.mutable=Make {0} ''{1}'' mutable
haxe.quickfix.make.immutable=Make {0} ''{1}'' immutable
haxe.quickfix.remove.type.check=Remove type check
haxe.quickfix.change.type.check.to.0=Change type check to {0}
haxe.quickfix.change.variable.type=Change variable type
haxe.quickfix.remove.initializer=Remove initializer
haxe.quickfix.remove.duplicate=Remove duplicate ''{0}''
haxe.quickfix.surround.with.single.quotation.marks=Surround with single quotation marks
haxe.quickfix.surround.with.double.quotation.marks=Surround with double quotation marks
haxe.quickfix.surround.with.curly.braces=Surround with curly braces
haxe.quickfix.surround.with.brackets=Surround with brackets
haxe.quickfix.surround.with.parenthesis=Surround with parenthesis
haxe.quickfix.wrap.assignment.with.parenthesis=Wrap assignment with parenthesis
haxe.quickfix.wrap.is.expression.with.parenthesis=Wrap "is" expression with parenthesis
haxe.quickfix.wrap.expression.with.parenthesis=Wrap expression with parenthesis.
haxe.quickfix.wrap.left.hand.side.with.parenthesis=Wrap left-hand side with parenthesis.
haxe.quickfix.missing.semi.colon=Add missing semicolon.

# HAXE parameter info helper
haxe.parameter.info.helper.no.parameters=No parameters
haxelib.dependency.list.prefix=Dependency of 
haxelib.dependency.list.separator=, 

# HAXE Module settings dialog.
module.settings.synchronize.dependencies=Use Haxe project files  and haxelib to update module dependencies and settings.  (Project file changes update IDEA settings; IDEA does not update Haxe project files.)
module.settings.synchronize.dependencies.title=Automatically s&ynchronize dependencies and settings

# Parsing
parsing.error.missing.semi.colon=Missing semicolon.

# Debug Exceptions
invalid.value.detected.at.runtime=Invalid value detected at runtime\: {0}
invalid.case.value.unadorned=Unexpected case encountered in switch statement.
invalid.case.value=Unexpected case encountered in switch statement\: {0}

# Folding settings
exportable.HaxeFoldingSettings.presentable.name=Code Folding Settings

#HaxelibProjectUpdater messages
haxelib.synchronization.title=Haxelib Synchronization
library.source.root.was.not.found.0=Library source root was not found\: {0}
could.not.determine.library.source.root.0=Could not determine library source root\: {0}

#Haxe default folding settings
haxe.idea.style.regions=Haxe: IDEA style regions: /* region title */ ... /* end region */
haxe.flashdevelop.style.regions=Haxe: FlashDevelop style regions:  /*{ region title */ ... /*} end region */
haxe.c.as3.style.regions=Haxe: C#/AS3 style regions: /*# region title */ ... /*# end region */
haxe.unused.conditionally.compiled.code=Haxe: Unused conditionally compiled code: #if/#else/#elseif/#end


dialog.import.on.paste.title=Select Classes to Import
dialog.paste.on.import.text=<html>The code fragment which you have pasted uses classes that are not accessible by imports in the new context.<br/>Select classes that you want to import to the new file.</html>

dialog.module.name-conflict.title=Module Name Conflict
dialog.module.name-conflict.message=There already exists a module with name {0} ({1}) do you want to replace it?"

action.structureview.show.fields=Show Fields

haxe.haxelib.library.missing.install=Install Using Haxelib
haxe.haxelib.library.missing.without.version=Haxelib could not find library named {0}
haxe.haxelib.library.missing.with.version=Haxelib could not find library named {0} version {1}
haxe.haxelib.library.missing.install.failed.with.version=Could not install {0} {1}
haxe.haxelib.library.missing.install.failed.without.version=Could not install {0}
haxe.haxelib.library.dependencies=Haxe project dependencies